// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: event_participants.sql

package db

import (
	"context"
	"database/sql"
)

const addEventParticipant = `-- name: AddEventParticipant :exec
INSERT INTO event_participants (event_id, user_id, can_attend)
VALUES ($1, $2, $3)
ON CONFLICT (event_id, user_id) DO NOTHING
`

type AddEventParticipantParams struct {
	EventID   int32        `json:"event_id"`
	UserID    int32        `json:"user_id"`
	CanAttend sql.NullBool `json:"can_attend"`
}

func (q *Queries) AddEventParticipant(ctx context.Context, arg AddEventParticipantParams) error {
	_, err := q.db.ExecContext(ctx, addEventParticipant, arg.EventID, arg.UserID, arg.CanAttend)
	return err
}

const getEventParticipants = `-- name: GetEventParticipants :many
SELECT event_id, user_id, can_attend
FROM event_participants
WHERE event_id = $1
`

func (q *Queries) GetEventParticipants(ctx context.Context, eventID int32) ([]EventParticipant, error) {
	rows, err := q.db.QueryContext(ctx, getEventParticipants, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EventParticipant{}
	for rows.Next() {
		var i EventParticipant
		if err := rows.Scan(&i.EventID, &i.UserID, &i.CanAttend); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getParticipantStatus = `-- name: GetParticipantStatus :one
SELECT event_id, user_id, can_attend
FROM event_participants
WHERE event_id = $1 AND user_id = $2
`

type GetParticipantStatusParams struct {
	EventID int32 `json:"event_id"`
	UserID  int32 `json:"user_id"`
}

func (q *Queries) GetParticipantStatus(ctx context.Context, arg GetParticipantStatusParams) (EventParticipant, error) {
	row := q.db.QueryRowContext(ctx, getParticipantStatus, arg.EventID, arg.UserID)
	var i EventParticipant
	err := row.Scan(&i.EventID, &i.UserID, &i.CanAttend)
	return i, err
}

const listUserEvents = `-- name: ListUserEvents :many
SELECT event_id, user_id, can_attend
FROM event_participants
WHERE user_id = $1
ORDER BY event_id
`

func (q *Queries) ListUserEvents(ctx context.Context, userID int32) ([]EventParticipant, error) {
	rows, err := q.db.QueryContext(ctx, listUserEvents, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EventParticipant{}
	for rows.Next() {
		var i EventParticipant
		if err := rows.Scan(&i.EventID, &i.UserID, &i.CanAttend); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeEventParticipant = `-- name: RemoveEventParticipant :exec
DELETE FROM event_participants
WHERE event_id = $1 AND user_id = $2
`

type RemoveEventParticipantParams struct {
	EventID int32 `json:"event_id"`
	UserID  int32 `json:"user_id"`
}

func (q *Queries) RemoveEventParticipant(ctx context.Context, arg RemoveEventParticipantParams) error {
	_, err := q.db.ExecContext(ctx, removeEventParticipant, arg.EventID, arg.UserID)
	return err
}

const updateAttendanceStatus = `-- name: UpdateAttendanceStatus :exec
UPDATE event_participants
SET can_attend = $3
WHERE event_id = $1 AND user_id = $2
`

type UpdateAttendanceStatusParams struct {
	EventID   int32        `json:"event_id"`
	UserID    int32        `json:"user_id"`
	CanAttend sql.NullBool `json:"can_attend"`
}

func (q *Queries) UpdateAttendanceStatus(ctx context.Context, arg UpdateAttendanceStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateAttendanceStatus, arg.EventID, arg.UserID, arg.CanAttend)
	return err
}
